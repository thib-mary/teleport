---
authors: Tim Ross (tim.ross@goteleport.com)
state: draft
---

# RFD 153 - Resource Guidelines

## Required approvers

- Engineering: `@zmb3`

## What

Guidelines for creating backend resources and APIs to interact with them.

## Why

To date resources follow slightly different patterns and have inconsistent APIs for creating, updating and deleting
them, see [#29234](https://github.com/gravitational/teleport/issues/29234). In addition to reducing confusion and
fostering a better developer experience, this will also remove complexity from the terraform provider and teleport
operator that have to accommodate for every subtle API and resource difference that exist today.

## Details

### Defining a resource

A resource at minimum MUST include a kind, version, `teleport.header.v1.Metadata` and a specification message with any
additional parameters needed to represent the resource. The kind, version and metadata helps to identify the type of
resource, when it should expire, the version of the resource, etc. This is particularly important for ensuring that all
resources contain the same shape and that tools like `tctl` are able to leverage `services.UnknownResource` to identify
the resource and act appropriately.

```protobuf
import "teleport/header/v1/resourceheader.proto";

// Foo is a resource that does foo.
message Foo {
  // The kind of resource represented.
  string kind = 1;
  // An optional subkind to differentiate variations of the same kind.
  string sub_kind = 2;
  // The version of the resource being represented.
  string version = 3;
  // Common metadata that all resources shared.
  teleport.header.v1.Metadata metadata = 4;
  // The resource specific specification.
  FooSpec spec = 5;
}

// FooSpec contains resource specific properties.
message FooSpec {
  string bar = 1;
  int32 baz = 2;
  bool qux = 3;
}
```

This differs from existing resources because legacy resources make heavy use of features provided
by [gogoprotobuf](https://github.com/gogo/protobuf). Since that project has long been abandoned, we're striving to
migrate away from it as described in [RFD-0139](https://github.com/gravitational/teleport/pull/28386).
The `teleport.header.v1.Metadata` is a clone of `types.Metadata` which doesn't use any of the gogoproto features.
Legacy resources also had a `types.ResourceHeader` that used gogo magic to embed the type in the resource message. To
get around this, the required fields from the header MUST be included in the message itself. A non-gogo clone does exist
`teleport.header.v1.ResourceHeader`, however, to get the fields embeded custom marshalling must be manually written.

### API

All APIs should follow the following conventions that are largely based on
the [Google API style guide](https://cloud.google.com/apis/design/standard_methods).

#### Create

The `Create` RPC takes a resource to be created and must also return the newly created resource so that any fields that
are populated server side are provided to clients without requiring an additional call to `Get`.

The request MUST fail and return a `trace.AlreadyExists` error if a matching resource is already present in the backend.

```protobuf
// Creates a new Foo resource in the backend.
    rpc CreateFoo(CreateFooRequest) returns (CreateFooResponse);

message CreateFooRequest {
  // The desired Foo to be created.
  Foo foo = 1;
}

message CreateFooResponse {
  // The created Foo as it exists in the backend. The only differences between the returned
  // resource and the requested resource are due to properties that are updated by the server.
  // In most cases this will be limited to the Revision field of the Metadata in the ResourceHeader.
  Foo foo = 1;
}
```

When creating a new resource, the `backend.Backend.Create` method should be used to persist the resource. It is also
imperative that the revision generated by the backend is set on the returned resource.

```go
func (s *FooService) CreateFoo(ctx context.Context, foo foov1.Foo) (foov1.Foo, error) {
value, err := convertFooToValue(foo)
if err != nil {
return nil, trace.Wrap(err)
}
item := backend.Item{
Key:     backend.Key(foo, foo.GetName()),
Value:   value,
Expires: foo.Expiry(),
}

lease, err := s.Create(ctx, item)
if err != nil {
return nil, trace.Wrap(err)
}

// Update the foo with the revision generated by the backend during the write operation.
foo.SetRevision(lease.Revision)
return foo, nil
```

#### Update

The `Update` RPC takes a resource to be updated and must also return the updated resource so that any fields that are
populated server side are provided to clients without requiring an additional call to `Get`. If partial updates of a
resource are desired, the request may contain
a [FieldMask](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask).

The request MUST fail and return a `trace.NotFound` error if there is no matching resource in the backend.

```protobuf
// Updates an existing Foo in the backend.
    rpc UpdateFoo(UpdateFooRequest) returns (UpdateFooResponse);

message UpdateFooRequest {
  // The full Foo resource to update in the backend.
  Foo foo = 1;
  // A partial update for an existing Foo resource.
  FieldMask update_mask = 2;
}

message UpdateFooResponse {
  // The updated Foo as it exists in the backend. The only differences between the returned
  // resource and the requested resource are due to properties that are updated by the server.
  // In most cases this will be limited to the Revision field of the Metadata in the ResourceHeader.
  Foo foo = 1;
}
```

All update operations should prefer `backend.Backend.ConditionalUpdate` over the `backend.Backend.Update` method to
prevent blindly overwriting an existing item. When using conditional update, the backend write will only succeed if the
revision of the resource in the update request matches the revision of the item in the backend.

```go
func (s *FooService) UpdateFoo(ctx context.Context, foo foov1.Foo) (foov1.Foo, error) {
// The revision must be cached prior to converting to the value because 
// conversion functions will set the revision to "" if MarshalConfig.PreserveResourceID
// is not set.
rev := foo.GetRevision()
value, err := convertFooToValue(foo)
if err != nil {
return nil, trace.Wrap(err)
}
item := backend.Item{
Key:     backend.Key(foo, foo.GetName()),
Value:   value,
Expires: foo.Expiry(),
Revision: rev,
}

lease, err := s.ConditionalUpdate(ctx, item)
if err != nil {
return nil, trace.Wrap(err)
}

// Update the foo with the revision generated by the backend during the write operation.
foo.SetRevision(lease.Revision)
return foo, nil
```

#### Upsert

> The `Create` and `Update` RPCs should be preferred over `Upsert` for normal operations,
> see [#1326](https://github.com/gravitational/teleport/issues/1326) for more details. Upsert **is** however required
> for
> any resources which are cached.

The `Upsert` RPC takes a resource that will overwrite a matching existing resource or create a new resource if one does
not exist. The upserted resource is returned so that any fields that are populated server side are provided to clients
without requiring a call to `Get`.

```protobuf
// Creates a new Foo or updates an existing Foo in the backend.
    rpc UpsertFoo(UpsertFooRequest) returns (UpsertFooResponse);

message UpsertFooRequest {
  // The full Foo resource to persist in the backend.
  Foo foo = 2;
}

message UpsertFooResponse {
  // The upserted Foo as it exists in the backend. The only differences between the returned
  // resource and the requested resource are due to properties that are updated by the server.
  // In most cases this will be limited to the Revision field of the Metadata in the ResourceHeader.
  Foo foo = 1;
}
```

When upserting a resource, the `backend.Backend.Put` method should be used to persist the resource. It is also
imperative that the revision generated by the backend is set on the returned resource.

```go

func (s *FooService) UpsertFoo(ctx context.Context, foo foov1.Foo) (foov1.Foo, error) {
value, err := convertFooToValue(foo)
if err != nil {
return nil, trace.Wrap(err)
}
item := backend.Item{
Key:     backend.Key(foo, foo.GetName()),
Value:   value,
Expires: foo.Expiry(),
}

lease, err := s.Put(ctx, item)
if err != nil {
return nil, trace.Wrap(err)
}

// Update the foo with the revision generated by the backend during the write operation.
foo.SetRevision(lease.Revision)
return foo, nil
```

#### Get

The `Get` RPC takes the parameters required to match a resource (usually the resource name should suffice), and returns
the matched resource. If a resource contains secrets (passwords, private keys, etc.) The request should also take
a `with_secrets` parameter that allows users to request the sensitive information. By default, the secrets should not be
provided in the response.

The request MUST fail and return a `trace.NotFound` error if there is no matching resource in the backend.

```protobuf
// Returns a single Foo matching the request
    rpc GetFoo(GetFooRequest) returns (GetFooResponse);

message GetFooRequest {
  // A filter to match the Foo by. Some resource may require more parameters to match and
  // may not use the name at all.
  string name = 1;
  // Specifies whether to load associated secrets with the resource.
  // NOTE: This is only required for resources which have secrets(passwords, 
  // private keys, mfa devices, etc). If a resource does not have any 
  // secrets this can be omitted.
  bool with_secrets = 2;
}

message GetFooResponse {
  // The matched Foo resource.
  Foo foo = 1;
}

```

#### List

The `List` RPC takes the requested page size and starting point and returns a list of resources that match. If there are
additional resources, the response MUST also include a token that indicates where the next page of results begins. If a
resource contains secrets (passwords, private keys, etc.) The request should also take a `with_secrets` parameter that
allows users to request the sensitive information. By default, the secrets should not be provided in the response.

```protobuf
// Returns a page of Foo and the token to find the next page of items.
    rpc ListFoo(ListFooRequest) returns (ListFooResponse);

message ListFoosRequest {
  // The maximum number of items to return.
  // The server may impose a different page size at its discretion.
  int32 page_size = 1;
  // The next_page_token value returned from a previous List request, if any.
  string page_token = 2;
  // Specifies whether to load associated secrets with the resource.
  // NOTE: This is only required for resources which have secrets(passwords, 
  // private keys, mfa devices, etc). If a resource does not have any 
  // secrets this can be omitted.
  bool with_secrets = 3;
}

message ListFoosResponse {
  // The page of Foo that matched the request.
  repeated Foo foos = 1;
  // Token to retrieve the next page of results, or empty if there are no
  // more results in the list.
  string next_page_token = 2;
}
```

A listing operation should not abort entirely if a single item cannot be (un)marshalled, it should instead be logged,
and the rest of the page should be processed. Aborting an entire page when a single entry is invalid causes the cache
to be permanently unhealthy since it is never able to initialize loading the affected resource.

#### Delete

The `Delete` RPC takes the parameters required to match a resource (usually the resource name should suffice), and
removes the specified resource from the backend and returns a `google.protobuf.Empty`.

The request MUST fail and return a `trace.NotFound` error if there is no matching resource in the backend.

```protobuf
// Remove a matching Foo resource
    rpc DeleteFoo(DeleteFooRequest) returns (google.protobuf.Empty);

message DeleteFooRequest {
  // Name of the foo to remove. Some resource may require more parameters to match and
  // may not use the name at all.
  string name = 1;
}
```

### Proto Specification

Below is the entire specification for the examples above.

<details open><summary>Foo Proto</summary>

```protobuf
syntax = "proto3";

package teleport.foo.v1;

import "teleport/header/v1/resourceheader.proto";

option go_package = "github.com/gravitational/teleport/api/gen/proto/go/teleport/foo/v1;foov1";

// Foo is a resource that does foo.
message Foo {
  // Header contains the common metadata that all resources must have.
  teleport.header.v1.ResourceHeader header = 1;

  // Define the resource specific properties below. The ones
  // defined here are just examples.
  string bar = 2;
  int32 baz = 3;
  bool qux = 4;
}

// FooService provides an API to manage Foos.
service FooService {
  // GetFoo returns the specified Foo resource.
  rpc GetFoo(GetFooRequest) returns (GetFooResponse);

  // ListFoo returns a page of Foo resources.
  rpc ListFoo(ListFooRequest) returns (ListFooResponse);

  // CreateFoo creates a new Foo resource.
  rpc CreateFoo(CreateFooRequest) returns (CreateFooResponse);

  // UpdateFoo updates an existing Foo resource.
  rpc UpdateFoo(UpdateFooRequest) returns (UpdateFooResponse);

  // UpsertFoo creates or updates a Foo resource.
  rpc UpsertFoo(UpsertFooRequest) returns (UpsertFooResponse);

  // DeleteFoo removes the specified Foo resource.
  rpc DeleteFoo(DeleteFooRequest) returns (google.protobuf.Empty);
}

// Request for GetFoo.
message GetFooRequest {
  // The name of the Foo resource to retrieve.
  string name = 1;

  // Specifies whether to load associated secrets with the resource.
  // NOTE: This is only required for resources which have secrets(passwords, 
  // private keys, mfa devices, etc). If a resource does not have any 
  // secrets this can be omitted.
  bool with_secrets = 2;
}

// Response for GetFoo.
message GetFooResponse {
  // The foo matching the request filters.
  Foo foo = 1;
}

// Request for ListFoos.
//
// Follows the pagination semantics of
// https://cloud.google.com/apis/design/standard_methods#list.
message ListFoosRequest {
  // The maximum number of items to return.
  // The server may impose a different page size at its discretion.
  int32 page_size = 1;

  // The next_page_token value returned from a previous ListFoo request, if any.
  string page_token = 2;

  // Specifies whether to load associated secrets with the resource.
  // NOTE: This is only required for resources which have secrets(passwords, 
  // private keys, mfa devices, etc). If a resource does not have any 
  // secrets this can be omitted.
  bool with_secrets = 3;
}

// Response for ListFoos.
message ListFoosResponse {
  // Foo that matched the search.
  repeated Foo foos = 1;

  // Token to retrieve the next page of results, or empty if there are no
  // more results exist.
  string next_page_token = 2;
}

// Request for CreateFoo.
message CreateFooRequest {
  // The foo resource to create.
  Foo foo = 1;
}

// Response for CreateFoo.
message CreateFooResponse {
  // The created foo with any server side generated fields populated.
  Foo foo = 1;
}

// Request for UpdateFoo.
message UpdateFooRequest {
  // The foo resource to update.
  Foo foo = 2;

  // The update mask applied to a Foo.
  // Fields are masked according to their proto name.
  FieldMask update_mask = 2;
}

// Response for UpdateFoo.
message UpdateFooResponse {
  // The updated foo with any server side generated fields populated.
  Foo foo = 1;
}

// Request for UpsertFoo.
message UpsertFooRequest {
  // The foo resource to upsert.
  Foo foo = 2;
}

// Response for UpsertFoo.
message UpsertFooResponse {
  // The upserted foo with any server side generated fields populated.
  Foo foo = 1;
}

// Request for DeleteFoo.
message DeleteFooRequest {
  // Name of the foo to remove.
  string name = 1;
}
```

</details>

### Backward Compatibility

Changing existing resources which do not follow the guidelines laid out in this RFD may lead to breaking changes. It is
not recommended to change existing resources for change’s sake. Migrating APIs which do not conform to the
recommendations in this RFD can be made in a backward compatible manner. This can be achieved by adding new APIs that
conform with the advice above and falling back to the existing APIs if a `trace.NotImplemented` error is received. Once
all compatible versions of Teleport are using the new version of the API, the old API may be cleaned up.